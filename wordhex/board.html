<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wordhex – Discord Activity</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #090b12;
      --bg-alt: #121728;
      --panel: rgba(20, 26, 44, 0.85);
      --accent: #8c71ff;
      --accent-strong: #b891ff;
      --accent-soft: rgba(140, 113, 255, 0.2);
      --text: #f8f9ff;
      --muted: #b5b9d8;
      --danger: #ff668c;
      --success: #5cf1c5;
      --tile-bg: rgba(18, 23, 40, 0.9);
      --tile-border: rgba(140, 113, 255, 0.4);
      --gem: #58f1ff;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at top, rgba(140, 113, 255, 0.25), transparent 55%),
        radial-gradient(circle at bottom, rgba(88, 241, 255, 0.18), transparent 45%),
        var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2.5rem 1.5rem 3rem;
      gap: 2rem;
    }

    header {
      text-align: center;
    }

    h1 {
      font-size: clamp(2.25rem, 4vw, 3rem);
      letter-spacing: 0.12em;
      text-transform: uppercase;
      margin: 0 0 0.5rem;
    }

    header p {
      margin: 0;
      color: var(--muted);
      font-size: 1.05rem;
    }

    main {
      display: grid;
      grid-template-columns: minmax(260px, 300px) minmax(320px, 1fr) minmax(260px, 320px);
      gap: 1.5rem;
      width: min(1100px, 100%);
    }

    #lobby-hub {
      width: min(1100px, 100%);
      padding: 1.8rem;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    .lobby-grid {
      display: grid;
      grid-template-columns: 2fr 1fr 1fr;
      gap: 1.25rem;
      align-items: center;
    }

    .lobby-channel .channel-name {
      font-size: 1.25rem;
      font-weight: 600;
    }

    .lobby-pin,
    .lobby-meta {
      background: rgba(255, 255, 255, 0.03);
      padding: 1rem;
      border-radius: 16px;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: flex-start;
    }

    .pin-code {
      font-size: 1.8rem;
      letter-spacing: 0.2em;
      font-weight: 700;
    }

    .match-settings {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }

    .setting-item {
      padding: 1rem;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.03);
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .setting-item span {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .panel {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 20px;
      padding: 1.4rem;
      box-shadow: 0 40px 80px rgba(9, 11, 18, 0.55);
      backdrop-filter: blur(14px);
    }

    .panel h2 {
      font-size: 1.05rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      margin: 0 0 1rem;
      color: var(--muted);
    }

    .label {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    #board {
      display: grid;
      gap: 0.75rem;
      grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
    }

    #board button.tile {
      all: unset;
      position: relative;
      border-radius: 16px;
      padding: 1rem 0.35rem 0.55rem;
      background: var(--tile-bg);
      border: 1px solid transparent;
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 0.15rem;
      cursor: pointer;
      transition: transform 0.18s ease, border-color 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
    }

    #board button.tile:hover,
    #board button.tile:focus-visible {
      transform: translateY(-4px);
      border-color: var(--tile-border);
      box-shadow: 0 18px 30px rgba(9, 11, 18, 0.65);
    }

    #board button.tile:focus-visible {
      border-color: var(--accent);
    }

    #board button.tile .letter {
      font-size: clamp(1.25rem, 2vw, 1.7rem);
      font-weight: 700;
    }

    #board button.tile .value {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--muted);
      background: rgba(255, 255, 255, 0.04);
      padding: 0.25rem 0.55rem;
      border-radius: 999px;
      margin-top: 0.35rem;
    }

    .tile[data-multiplier="DL"] {
      border-color: rgba(88, 241, 197, 0.5);
    }

    .tile[data-multiplier="TL"] {
      border-color: rgba(255, 200, 120, 0.6);
    }

    .tile[data-word="DW"] {
      box-shadow: inset 0 0 0 2px rgba(140, 113, 255, 0.4);
    }

    .tile[data-word="TW"] {
      box-shadow: inset 0 0 0 2px rgba(255, 102, 140, 0.5);
    }

    .tile[data-gem="true"]::after {
      content: "\2726";
      position: absolute;
      top: 8px;
      right: 10px;
      font-size: 0.8rem;
      color: var(--gem);
    }

    #scoreboard ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    #scoreboard li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 0.85rem;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 14px;
      font-weight: 600;
      flex-wrap: wrap;
      gap: 0.25rem;
    }

    #scoreboard li.active {
      border: 1px solid var(--accent);
      box-shadow: 0 10px 24px rgba(140, 113, 255, 0.25);
    }

    #scoreboard li[data-ready="false"] {
      opacity: 0.75;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      margin-left: 0.35rem;
    }

    .tag.host {
      background: rgba(140, 113, 255, 0.2);
      color: var(--accent);
    }

    #scoreboard li.empty {
      justify-content: center;
      color: var(--muted);
      font-weight: 500;
    }

    .lobby-status {
      margin-top: 1rem;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .player-actions {
      margin-top: 0.75rem;
      display: flex;
      gap: 0.5rem;
    }

    button {
      border: none;
      border-radius: 12px;
      padding: 0.65rem 1.1rem;
      font-size: 0.95rem;
      font-weight: 600;
      background: var(--accent);
      color: var(--text);
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    button.secondary {
      background: rgba(255, 255, 255, 0.08);
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 12px 24px rgba(140, 113, 255, 0.35);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }

    form {
      display: grid;
      gap: 0.75rem;
      margin-top: 1rem;
    }

    input[type="text"] {
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 0.7rem 1rem;
      font-size: 1rem;
      background: rgba(255, 255, 255, 0.05);
      color: var(--text);
    }

    input[type="text"]:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    #word-history {
      margin-top: 1.5rem;
      display: grid;
      gap: 0.6rem;
    }

    .word-entry {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.6rem 0.75rem;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
      font-size: 0.9rem;
    }

    .word-entry span {
      opacity: 0.75;
    }

    #gems {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 1.25rem;
      padding-top: 1.25rem;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
    }

    #gem-count {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 1.1rem;
      font-weight: 600;
    }

    #gem-count::before {
      content: "\2726";
      color: var(--gem);
      font-size: 1.25rem;
    }

    .gem-actions {
      display: grid;
      gap: 0.75rem;
      margin-top: 1.25rem;
    }

    .gem-actions button {
      background: rgba(140, 113, 255, 0.2);
      border: 1px solid rgba(140, 113, 255, 0.45);
      color: var(--text);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .gem-actions button span {
      opacity: 0.75;
      font-size: 0.85rem;
      font-weight: 500;
    }

    #status {
      margin-top: 1.25rem;
      font-size: 0.9rem;
      color: var(--muted);
      text-align: center;
    }

    #multiplayer {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    #activity-feed {
      background: rgba(255, 255, 255, 0.03);
      padding: 1rem;
      border-radius: 16px;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    #activity-feed h3 {
      margin: 0;
      font-size: 1rem;
    }

    .feed-entry {
      display: flex;
      justify-content: space-between;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 0.6rem 0.75rem;
      font-size: 0.9rem;
    }

    .subtle {
      color: var(--muted);
      font-size: 0.85rem;
      margin: 0.25rem 0 0;
    }

    .host-name-row {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    .host-name-row button {
      font-size: 0.75rem;
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      border: 1px solid transparent;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
    }

    .host-name-row button:not(:disabled):hover {
      border-color: rgba(255, 255, 255, 0.4);
    }

    @media (max-width: 1100px) {
      main {
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      }
      .lobby-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 840px) {
      main {
        grid-template-columns: 1fr;
      }

      body {
        padding: 1.5rem 1rem 2rem;
      }

      .lobby-grid {
        grid-template-columns: 1fr;
      }

      .panel {
        padding: 1.25rem;
      }

      #match-settings {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      }
    }

    @media (max-width: 600px) {
      body {
        padding: 1.25rem 0.85rem 1.75rem;
      }
      .host-name-row {
        flex-direction: column;
        align-items: flex-start;
      }
      #board {
        gap: 0.5rem;
      }
      #board button.tile {
        padding: 0.85rem 0.3rem 0.45rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Wordhex</h1>
    <p>SpellCast-inspired multiplayer word hunt built for Discord Activities.</p>
  </header>

  <section id="lobby-hub" class="panel">
    <div class="lobby-grid">
      <div class="lobby-channel">
        <span class="label">Connected Voice Channel</span>
        <div class="channel-name" id="lobby-channel-name">#spellcast-practice</div>
        <p class="subtle">Match audio + Discord reactions sync here.</p>
      </div>
      <div class="lobby-pin">
        <span class="label">Lobby PIN</span>
        <div class="pin-code" id="lobby-code">8421</div>
        <button id="share-lobby">Copy Invite</button>
      </div>
      <div class="lobby-meta">
        <div>
          <span class="label">Host</span>
          <div class="host-name-row">
            <strong id="lobby-host">You</strong>
            <button id="edit-host-name" class="secondary host-rename" type="button" hidden>Rename</button>
          </div>
        </div>
        <div>
          <span class="label">Players Ready</span>
          <strong id="ready-count">0 / 0</strong>
        </div>
        <button id="start-match">Start Match</button>
      </div>
    </div>

    <div class="match-settings" id="match-settings"></div>
  </section>

  <main>
    <aside class="panel" id="scoreboard">
      <h2>Players</h2>
      <ul id="player-list"></ul>

      <div id="lobby-status" class="lobby-status">Setting up lobby…</div>

      <div class="player-actions">
        <button id="ready-up" class="secondary">Ready Up</button>
      </div>

      <div id="status">Loading Discord SDK…</div>
    </aside>

    <section class="panel">
      <h2>Active Board</h2>
      <div id="board" aria-live="polite"></div>

      <form id="word-form" autocomplete="off">
        <label for="word-input">Submit a word</label>
        <input id="word-input" name="word" type="text" placeholder="Type your word" required minlength="2" />
        <button type="submit">Submit Word</button>
      </form>

      <div id="word-history"></div>
    </section>

    <aside class="panel" id="multiplayer">
      <h2>Gem Abilities</h2>
      <div id="gems">
        <span>Gem Reserve</span>
        <div id="gem-count">3</div>
      </div>

      <div class="gem-actions">
        <button data-action="shuffle">
          Shuffle Board
          <span>Cost: 1</span>
        </button>
        <button data-action="swap">
          Swap Tiles
          <span>Cost: 3</span>
        </button>
        <button data-action="hint">
          Reveal Hint
          <span>Cost: 4</span>
        </button>
      </div>

      <section id="activity-feed">
        <header>
          <h3>Match Feed</h3>
          <span class="label">Live events for everyone in the lobby.</span>
        </header>
        <div id="feed-entries"></div>
      </section>

    </aside>
  </main>

  <script src="https://discord.com/sdk/embedded.js"></script>
  <script type="module">
    import { lobbyService, ensurePlayerProfile, updatePlayerProfile, LOBBY_DEFAULTS } from "./scripts/lobby-service.js";

    const status = document.getElementById("status");
    const boardEl = document.getElementById("board");
    const wordForm = document.getElementById("word-form");
    const wordInput = document.getElementById("word-input");
    const wordHistory = document.getElementById("word-history");
    const playerList = document.getElementById("player-list");
    const gemCountEl = document.getElementById("gem-count");
    const gemButtons = document.querySelectorAll(".gem-actions button");
    const readyButton = document.getElementById("ready-up");
    const lobbyStatus = document.getElementById("lobby-status");
    const readyCountEl = document.getElementById("ready-count");
    const lobbyCodeEl = document.getElementById("lobby-code");
    const lobbyHostEl = document.getElementById("lobby-host");
    const lobbyChannelEl = document.getElementById("lobby-channel-name");
    const shareLobbyBtn = document.getElementById("share-lobby");
    const startMatchBtn = document.getElementById("start-match");
    const matchSettingsEl = document.getElementById("match-settings");
    const feedEntries = document.getElementById("feed-entries");
    const editHostNameBtn = document.getElementById("edit-host-name");

    const letterPool = [
      { letters: "AEIO", value: 1, weight: 32 },
      { letters: "DGLNRSTU", value: 2, weight: 28 },
      { letters: "BCFHMVPWY", value: 3, weight: 20 },
      { letters: "K", value: 4, weight: 8 },
      { letters: "JX", value: 5, weight: 6 },
      { letters: "QZ", value: 8, weight: 6 }
    ];

    const multiplierTiles = ["DL", "DL", "TL", "TL"];
    const wordTiles = ["DW", "DW", "TW"];
    const gemTileCount = 5;

    let board = [];
    let gemCount = 3;

    let playerProfile = ensurePlayerProfile();
    let activeLobby = null;
    let unsubscribeLobby = null;

    const getCachedLobbyCode = () => {
      try {
        return sessionStorage.getItem("wordhex:lastLobbyCode");
      } catch (error) {
        console.warn("Unable to read cached lobby code", error);
        return null;
      }
    };

    const cacheLobbyCode = (code) => {
      try {
        sessionStorage.setItem("wordhex:lastLobbyCode", code);
      } catch (error) {
        console.warn("Unable to cache lobby code", error);
      }
    };

    const params = new URLSearchParams(window.location.search);
    let lobbyCode = params.get("code") || getCachedLobbyCode() || lobbyService.generateLobbyCode();

    if (!params.get("code")) {
      const nextUrl = new URL(window.location.href);
      nextUrl.searchParams.set("code", lobbyCode);
      window.history.replaceState({}, "", nextUrl);
    }

    cacheLobbyCode(lobbyCode);

    const activityFeed = [];

    const renderPlayers = () => {
      playerList.innerHTML = "";
      const players = activeLobby?.players ? [...activeLobby.players].sort((a, b) => (b.score || 0) - (a.score || 0)) : [];
      if (!players.length) {
        const empty = document.createElement("li");
        empty.className = "empty";
        empty.textContent = "Share your lobby code to invite players.";
        playerList.appendChild(empty);
        return;
      }

      players.forEach((player, index) => {
        const li = document.createElement("li");
        li.dataset.ready = player.ready;
        if (player.id === playerProfile.id) {
          li.classList.add("active");
        }
        const readyLabel = player.ready ? "Ready" : "Waiting";
        const isHost = player.id === activeLobby?.hostId;
        const hostTag = isHost ? '<span class="tag host">Host</span>' : "";
        li.innerHTML = `
          <div>
            <span>${index + 1}. ${player.name}</span>
            ${hostTag}
            <span class="tag">${readyLabel}</span>
          </div>
          <span>${player.score ?? 0}</span>
        `;
        playerList.appendChild(li);
      });
    };

    const buildMatchSettings = () => {
      const settings = activeLobby?.settings || {};
      const rounds = settings.rounds ?? LOBBY_DEFAULTS.rounds;
      const roundDuration = settings.roundDuration ?? settings.roundDurationSeconds ?? LOBBY_DEFAULTS.roundDuration;
      const roundDurationLabel =
        roundDuration > 0 ? `${rounds} (${roundDuration}s each)` : `${rounds} (No timer)`;
      return [
        { label: "Game Mode", value: settings.mode ?? LOBBY_DEFAULTS.mode },
        { label: "Rounds", value: roundDurationLabel },
        { label: "Win Condition", value: settings.winCondition ?? LOBBY_DEFAULTS.winCondition },
        { label: "Dictionary", value: settings.dictionary ?? LOBBY_DEFAULTS.dictionary }
      ];
    };

    const renderMatchSettings = () => {
      matchSettingsEl.innerHTML = "";
      buildMatchSettings().forEach((setting) => {
        const div = document.createElement("div");
        div.className = "setting-item";
        div.innerHTML = `
          <span>${setting.label}</span>
          <strong>${setting.value}</strong>
        `;
        matchSettingsEl.appendChild(div);
      });
    };

    const applyLobbyState = () => {
      renderPlayers();
      renderMatchSettings();
      updateLobbyMeta();
    };

    const updateHostControls = () => {
      const isHost = activeLobby?.hostId === playerProfile.id;
      if (editHostNameBtn) {
        editHostNameBtn.hidden = !isHost;
      }
    };

    const handleHostRename = () => {
      if (!activeLobby || activeLobby.hostId !== playerProfile.id) return;
      const currentName = lobbyHostEl.textContent.trim();
      const nextName = window.prompt("Set your host display name", currentName) ?? "";
      const normalized = nextName.trim();
      if (!normalized || normalized === currentName) return;
      playerProfile = updatePlayerProfile({ name: normalized });
      lobbyService.updatePlayerName(activeLobby.code, playerProfile.id, normalized);
    };

    editHostNameBtn?.addEventListener("click", handleHostRename);

    const initLobbySync = () => {
      lobbyService.ensureLobby(lobbyCode, {
        hostId: playerProfile.id,
        hostName: playerProfile.name
      });
      lobbyService.joinLobby(lobbyCode, {
        id: playerProfile.id,
        name: playerProfile.name,
        score: 0,
        ready: false,
        isActive: true
      });
      if (typeof unsubscribeLobby === "function") {
        unsubscribeLobby();
      }
      unsubscribeLobby = lobbyService.subscribeToLobby(lobbyCode, (lobby) => {
        activeLobby = lobby;
        cacheLobbyCode(lobby.code);
        applyLobbyState();
      });
      activeLobby = lobbyService.getLobby(lobbyCode);
      applyLobbyState();
    };

    const updateLobbyMeta = () => {
      if (!activeLobby) {
        readyCountEl.textContent = "0 / 0";
        lobbyStatus.textContent = "Setting up lobby…";
        readyButton.disabled = true;
        startMatchBtn.disabled = true;
        updateHostControls();
        return;
      }

      const players = activeLobby.players || [];
      const readyCount = players.filter((player) => player.ready).length;
      readyCountEl.textContent = `${readyCount} / ${players.length}`;
      const isHost = activeLobby.hostId === playerProfile.id;

      let statusMessage = "";
      if (!players.length) {
        statusMessage = "Waiting for players to join this lobby.";
      } else if (activeLobby.status === "active") {
        statusMessage = "Match in progress.";
      } else if (readyCount === players.length) {
        statusMessage = "All players ready—host can start the match.";
      } else {
        statusMessage = `${readyCount} of ${players.length} players ready.`;
      }
      lobbyStatus.textContent = statusMessage;

      startMatchBtn.disabled =
        !isHost || activeLobby.status === "active" || players.length === 0 || readyCount !== players.length;
      readyButton.disabled = activeLobby.status === "active";

      const currentPlayer = players.find((player) => player.id === playerProfile.id);
      readyButton.textContent = currentPlayer?.ready ? "Cancel Ready" : "Ready Up";
      lobbyHostEl.textContent = activeLobby.hostName || "Host";
      lobbyChannelEl.textContent = activeLobby.channel || LOBBY_DEFAULTS.channel;
      lobbyCodeEl.textContent = activeLobby.code;
      updateHostControls();
    };

    const renderFeed = () => {
      feedEntries.innerHTML = "";
      if (!activityFeed.length) return;
      activityFeed.forEach((entry) => {
        const div = document.createElement("div");
        div.className = "feed-entry";
        div.innerHTML = `
          <div>
            <strong>${entry.player}</strong> ${entry.detail}
          </div>
          <span>${entry.value}</span>
        `;
        feedEntries.appendChild(div);
      });
    };

    const randomLetter = () => {
      const totalWeight = letterPool.reduce((sum, set) => sum + set.weight, 0);
      const target = Math.random() * totalWeight;
      let cumulative = 0;
      for (const set of letterPool) {
        cumulative += set.weight;
        if (target <= cumulative) {
          const letters = set.letters;
          const letter = letters[Math.floor(Math.random() * letters.length)];
          return { letter, value: set.value };
        }
      }
      return { letter: "E", value: 1 };
    };

    const generateBoard = () => {
      const tiles = Array.from({ length: 25 }, () => ({ ...randomLetter(), id: crypto.randomUUID() }));
      const availableIndexes = [...tiles.keys()];

      const assignSpecial = (tilesToAssign, key) => {
        for (const type of tilesToAssign) {
          if (!availableIndexes.length) break;
          const idx = availableIndexes.splice(Math.floor(Math.random() * availableIndexes.length), 1)[0];
          tiles[idx] = { ...tiles[idx], [key]: type };
        }
      };

      assignSpecial(multiplierTiles, "multiplier");
      assignSpecial(wordTiles, "word");

      const gemIndexes = [...availableIndexes].sort(() => Math.random() - 0.5).slice(0, gemTileCount);
      for (const idx of gemIndexes) {
        tiles[idx] = { ...tiles[idx], gem: true };
      }

      return tiles;
    };

    const addLetterToInput = (letter) => {
      if (!wordInput) return;
      wordInput.value = `${wordInput.value}${letter}`;
      wordInput.focus();
    };

    const renderBoard = () => {
      boardEl.innerHTML = "";
      board.forEach((tile) => {
        const tileEl = document.createElement("button");
        tileEl.type = "button";
        tileEl.className = "tile";
        if (tile.multiplier) tileEl.dataset.multiplier = tile.multiplier;
        if (tile.word) tileEl.dataset.word = tile.word;
        if (tile.gem) tileEl.dataset.gem = "true";
        tileEl.innerHTML = `
          <div class="letter">${tile.letter}</div>
          <div class="value">${tile.value}pt</div>
        `;
        tileEl.setAttribute("aria-label", `${tile.letter} tile, worth ${tile.value} points`);
        tileEl.addEventListener("click", () => addLetterToInput(tile.letter));
        boardEl.appendChild(tileEl);
      });
    };

    const updateGemCount = (value) => {
      gemCount = Math.max(0, Math.min(10, value));
      gemCountEl.textContent = gemCount;
      gemButtons.forEach((button) => {
        const cost = Number(button.querySelector("span").textContent.replace(/[^0-9]/g, ""));
        button.disabled = gemCount < cost;
      });
    };

    const spendGems = (cost) => {
      if (gemCount < cost) return false;
      updateGemCount(gemCount - cost);
      return true;
    };

    const applyShuffle = () => {
      if (!spendGems(1)) return;
      board = generateBoard();
      renderBoard();
      flashStatus("Board shuffled", "info");
    };

    const applySwap = () => {
      if (!spendGems(3)) return;
      const idxA = Math.floor(Math.random() * board.length);
      let idxB = Math.floor(Math.random() * board.length);
      while (idxB === idxA) idxB = Math.floor(Math.random() * board.length);
      [board[idxA], board[idxB]] = [board[idxB], board[idxA]];
      renderBoard();
      flashStatus("Two tiles swapped", "info");
    };

    const applyHint = () => {
      if (!spendGems(4)) return;
      const candidate = [...board].sort((a, b) => b.value - a.value)[0];
      if (!candidate) return;
      flashStatus(`Look for words with <strong>${candidate.letter}</strong> for max value!`, "hint");
    };

    const actionHandlers = {
      shuffle: applyShuffle,
      swap: applySwap,
      hint: applyHint
    };

    gemButtons.forEach((button) => {
      button.addEventListener("click", () => {
        const action = button.dataset.action;
        actionHandlers[action]?.();
      });
    });

    readyButton.addEventListener("click", () => {
      if (!activeLobby || readyButton.disabled) return;
      lobbyService.togglePlayerReady(activeLobby.code, playerProfile.id);
    });

    startMatchBtn.addEventListener("click", () => {
      if (!activeLobby) return;
      const players = activeLobby.players || [];
      if (activeLobby.hostId !== playerProfile.id) {
        flashStatus("Only the host can start the match.", "error");
        status.style.color = "var(--danger)";
        return;
      }
      if (!players.length || players.some((player) => !player.ready)) {
        flashStatus("All players need to be ready before starting.", "error");
        status.style.color = "var(--danger)";
        return;
      }
      lobbyService.setLobbyStatus(activeLobby.code, "active");
      flashStatus("Match starting in Discord lobby", "success");
      status.style.color = "var(--success)";
    });

    shareLobbyBtn.addEventListener("click", async () => {
      if (!activeLobby) return;
      try {
        const invite = new URL(window.location.href);
        invite.searchParams.set("code", activeLobby.code);
        await navigator.clipboard.writeText(`Join my Wordhex lobby (${activeLobby.code}): ${invite.toString()}`);
        flashStatus("Invite code copied", "success");
      } catch (error) {
        console.error(error);
        flashStatus("Unable to copy invite", "error");
        status.style.color = "var(--danger)";
      }
    });

    const flashStatus = (message, type = "info") => {
      status.innerHTML = message;
      status.dataset.type = type;
      if (type === "hint") {
        status.style.color = "var(--success)";
      } else {
        status.style.color = "var(--muted)";
      }
      setTimeout(() => {
        status.style.color = "var(--muted)";
      }, 3200);
    };

    const scoreWord = (word) => {
      const letters = word.toUpperCase().split("");
      const letterCounts = {};
      letters.forEach((letter) => {
        letterCounts[letter] = (letterCounts[letter] || 0) + 1;
      });

      let baseScore = 0;
      let wordMultiplier = 1;
      let gemsEarned = 0;

      const boardCopy = board.map((tile) => ({ ...tile, used: false }));

      for (const letter of letters) {
        const tileIndex = boardCopy.findIndex((tile) => tile.letter === letter && !tile.used);
        if (tileIndex === -1) return null;

        const tile = boardCopy[tileIndex];
        tile.used = true;

        let letterScore = tile.value;
        if (tile.multiplier === "DL") letterScore *= 2;
        if (tile.multiplier === "TL") letterScore *= 3;
        baseScore += letterScore;

        if (tile.word === "DW") wordMultiplier *= 2;
        if (tile.word === "TW") wordMultiplier *= 3;
        if (tile.gem) gemsEarned += 1;
      }

      if (letters.length >= 6) baseScore += 10;

      gemsEarned = Math.min(gemsEarned, Math.max(0, 10 - gemCount));

      return {
        score: baseScore * wordMultiplier,
        gems: gemsEarned
      };
    };

    const addWordToHistory = (word, score) => {
      const entry = document.createElement("div");
      entry.className = "word-entry";
      entry.innerHTML = `<strong>${word.toUpperCase()}</strong><span>+${score} pts</span>`;
      wordHistory.prepend(entry);
    };

    wordForm.addEventListener("submit", (event) => {
      event.preventDefault();
      const formData = new FormData(wordForm);
      const submittedWord = String(formData.get("word")).trim();
      if (!submittedWord) return;
      const result = scoreWord(submittedWord);
      if (!result) {
        flashStatus("Letters must exist on the board", "error");
        status.style.color = "var(--danger)";
        return;
      }

      addWordToHistory(submittedWord, result.score);
      if (activeLobby) {
        lobbyService.incrementPlayerScore(activeLobby.code, playerProfile.id, result.score);
      }
      if (result.gems > 0) updateGemCount(gemCount + result.gems);
      flashStatus(`Word scored ${result.score} points`, "success");
      status.style.color = "var(--success)";
      wordForm.reset();
      wordInput.focus();
    });

    const initDiscord = async () => {
      const { discordSdk } = window;
      if (!discordSdk) {
        flashStatus("Discord SDK unavailable", "error");
        status.style.color = "var(--danger)";
        return;
      }

      try {
        await discordSdk.ready;
        const auth = await discordSdk.commands.authenticate();
        playerProfile = updatePlayerProfile({ name: auth.user.username });
        if (activeLobby) {
          lobbyService.updatePlayerName(activeLobby.code, playerProfile.id, playerProfile.name);
        }
        flashStatus(`Authenticated as ${auth.user.username}`, "success");
        status.style.color = "var(--success)";
      } catch (error) {
        console.error(error);
        flashStatus("Failed to authenticate with Discord", "error");
        status.style.color = "var(--danger)";
      }
    };

    const boot = () => {
      board = generateBoard();
      renderBoard();
      updateGemCount(gemCount);
      renderFeed();
      updateLobbyMeta();
      initLobbySync();
      initDiscord();
    };

    boot();
  </script>
</body>
</html>
